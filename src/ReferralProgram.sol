// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {LibPercentages} from "./libraries/LibPercentages.sol";
import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import {MainConsumerBase} from "../lib/redstone-oracles-monorepo/packages/evm-connector/contracts/data-services/MainDemoConsumerBase.sol";


error ReferralProgram__AddressIsZero();
error ReferralProgram_UnauthorizedAccess();
error ReferralProgram__UserAlreadyReferred();

contract ReferralProgram is Initializable, OwnableUpgradeable {
    
    event UserReferralAdded(address indexed referrer, address indexed referee);
    event FeeEarned(
        address indexed referrer,
        uint256 referrerReward,
        address indexed referee,
        uint256 refereeReward,
        address tokenIn
    );

    address private dexAggregatorV2;

     modifier onlyAggregator() {
        if (msg.sender != dexAggregatorV2) revert ReferralProgram_UnauthorizedAccess();
        _;
    }

     struct UserReferral {
        address referrer;
        address[] referees;
        address[] tokensEarned;
        mapping(address => uint256)  tokenToFeeAccumulated;
    }

    mapping(address => UserReferral) private userData;

    /**
    * @notice Initializes the ReferralFacet contract.
    * @dev This function sets the address of the DEX aggregator (DexAggregatorV2) and initializes the contract owner.
    * @param _dexAggregatorV2 The address of the DEX aggregator contract (DexAggregatorV2).
    */
    function initialize(address _dexAggregatorV2 ) public initializer {
        dexAggregatorV2 = _dexAggregatorV2;
        __Ownable_init();
    }

    /**
    * @dev User (A or B) makes a swap.
    * 10% of the fees is accumulated to the user’s B total amount.
    * 30% of the fees is accumulated to the user’s A total amount.
    * @param fee The amount of fees generated by the swap.
    * @param swapInitiator The address of the swap initiator (User B).
    * @param tokenIn The address of the token used in the swap.
    */
    function swap(uint256 fee, address swapInitiator, address tokenIn, address ref) external onlyAggregator {
        if (userData[swapInitiator].referrer == address(0) && ref != address(0)) {
            userData[swapInitiator].referrer = ref;
            userData[ref].referees.push(swapInitiator);
            emit UserReferralAdded(ref, swapInitiator);
        }
        UserReferral storage userAsReferee = userData[swapInitiator]; // Get the referrer for the initiator (User A).
        if (userAsReferee.referrer == address(0)) {
            // Do something if the initiator (User B) doesn't have a referrer (User A).
            // Emit event.
        } else {
        uint256 refereeReward = LibPercentages.percentage(fee, 1000); // 10% of fees for the referee.
        uint256 referrerReward = LibPercentages.percentage(fee, 3000); // 30% of fees for the referrer.
        address referrer = userAsReferee.referrer;
        UserReferral storage userAsReferrer = userData[referrer];
        userAsReferee.tokensEarned.push(tokenIn);
        userAsReferrer.tokensEarned.push(tokenIn);
        userAsReferee.tokenToFeeAccumulated[tokenIn] += refereeReward; // Accumulate the fees for the referee.
        userAsReferrer.tokenToFeeAccumulated[tokenIn] += referrerReward; // Accumulate the fees for the referrer.
        emit FeeEarned(referrer, referrerReward, swapInitiator, refereeReward, tokenIn);
        }

        
    }

    /**
     * @dev Get the referrer (User A) for a given referee (User B).
     * @param referee The address of the referee (User B).
     * @return The address of the referrer (User A).
     */
    function getReferrer(address referee) external view returns (address) {
        return userData[referee].referrer;
    }

    /**
     * @dev Get the referee (User B) for a given referrer (User A).
     * @param referrer The address of the referrer (User A).
     * @return The address of the referee (User B).
     */
    function getReferees(address referrer) external view returns (address[] memory) {
        return userData[referrer].referees;
    }

    /**
     * @dev Get the total tokens earned for a given user (User A or B).
     * @param user The address of the user (User A or B).
     * @return The array of addresses of tokens earned.
     */
    function getTokensEarned(address user) external view returns (address[] memory) {
        return userData[user].tokensEarned;
    }

    /**
     * @dev Get the total fees accumulated for a given user and token.
     * @param user The address of the user (User A or B).
     * @param token The address of the token.
     * @return The total fees accumulated for the user and token.
     */
    function getTokensEarnedAmount(address user, address token) external view returns (uint256) {
        return userData[user].tokenToFeeAccumulated[token];
    }

  
    /**
     * @dev Set the address of the DEX aggregator.
    * @param _dexAggregatorV2 The address of the DEX aggregator.
     */
    function setDexAggregatorV2(address _dexAggregatorV2) external onlyOwner {
        dexAggregatorV2 = _dexAggregatorV2;
    }
}