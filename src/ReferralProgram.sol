// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import {LibPercentages} from "./libraries/LibPercentages.sol";
import {Initializable} from "openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol";
import {OwnableUpgradeable} from "openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol";
import {AvalancheDataServiceConsumerBase} from "redstone-oracles-monorepo/packages/evm-connector/contracts/data-services/AvalancheDataServiceConsumerBase.sol";
import {ERC20} from "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";

// Define custom error messages
error ReferralProgram__AddressIsZero();
error ReferralProgram_UnauthorizedAccess();
error ReferralProgram__UserAlreadyReferred();

contract ReferralProgram is Initializable, OwnableUpgradeable, AvalancheDataServiceConsumerBase {

    event UserReferralAdded(address indexed referrer, address indexed referee);
    event FeeEarned(
        address indexed referrer,
        uint256 referrerReward,
        address indexed referee,
        uint256 refereeReward,
        address tokenIn
    );

    address private dexAggregatorV2;

    modifier onlyAggregator() {
        if (msg.sender != dexAggregatorV2) revert ReferralProgram_UnauthorizedAccess();
        _;
    }

    struct UserReferral {
        address referrer;
        address[] referees;
        address[] tokensEarned;
        mapping(address => uint256) tokenToFeeAccumulated;
    }

    mapping(address => UserReferral) private userData;
    address[] public allowedTokenAddresses = [0x62edc0692BD897D2295872a9FFCac5425011c661, 0xde3A24028580884448a5397872046a019649b084];

    string[] public allowedTokenSymbols = ["GMX", "USDT"];

    /**
     * @notice Initializes the ReferralFacet contract.
     * @dev This function sets the address of the DEX aggregator (DexAggregatorV2) and initializes the contract owner.
     * @param _dexAggregatorV2 The address of the DEX aggregator contract (DexAggregatorV2).
     */
    function initialize(address _dexAggregatorV2) public initializer {
        dexAggregatorV2 = _dexAggregatorV2;
        __Ownable_init();
    }

    /**
     * @dev User (A or B) makes a swap.
     * 10% of the fees is accumulated to the user’s B total amount.
     * 30% of the fees is accumulated to the user’s A total amount.
     * @param fee The amount of fees generated by the swap.
     * @param swapInitiator The address of the swap initiator (User B).
     * @param tokenIn The address of the token used in the swap.
     */
    function swap(uint256 fee, address swapInitiator, address tokenIn, address ref) external onlyAggregator {
        if (userData[swapInitiator].referrer == address(0) && ref != address(0)) {
            addReferral(ref, swapInitiator);
        }
        UserReferral storage userAsReferee = userData[swapInitiator]; // Get the referrer for the initiator (User A).
        address referrer = userAsReferee.referrer;
        uint256 refereeReward = LibPercentages.percentage(fee, 1000); // 10% of fees for the referee.
        uint256 referrerReward = LibPercentages.percentage(fee, 3000); // 30% of fees for the referrer.
        UserReferral storage userAsReferrer = userData[referrer];
        if (userHasToken(swapInitiator, tokenIn) == false) {
            userAsReferee.tokensEarned.push(tokenIn);
            userAsReferee.tokenToFeeAccumulated[tokenIn] += refereeReward; // Accumulate the fees for the referee.
        }
        if (userHasToken(referrer, tokenIn) == false) {
            userAsReferrer.tokensEarned.push(tokenIn);
            userAsReferrer.tokenToFeeAccumulated[tokenIn] += referrerReward; // Accumulate the fees for the referrer.
        }

        if (checkEarnedTokenUSD(swapInitiator, tokenIn) < 500) {
            userAsReferee.tokenToFeeAccumulated[tokenIn] += refereeReward;
        }

        if (checkEarnedTokenUSD(referrer, tokenIn) < 500) {
            userAsReferrer.tokenToFeeAccumulated[tokenIn] += referrerReward;
        }
        emit FeeEarned(referrer, referrerReward, swapInitiator, refereeReward, tokenIn);
    }

    /**
     * @dev Get the referrer (User A) for a given referee (User B).
     * @param referee The address of the referee (User B).
     * @return The address of the referrer (User A).
     */
    function getReferrer(address referee) external view returns (address) {
        return userData[referee].referrer;
    }

    /**
     * @dev Get the referee (User B) for a given referrer (User A).
     * @param referrer The address of the referrer (User A).
     * @return The address of the referee (User B).
     */
    function getReferees(address referrer) external view returns (address[] memory) {
        return userData[referrer].referees;
    }

    /**
     * @dev Get the total tokens earned for a given user (User A or B).
     * @param user The address of the user (User A or B).
     * @return The array of addresses of tokens earned.
     */
    function getTokensEarned(address user) external view returns (address[] memory) {
        return userData[user].tokensEarned;
    }

    /**
     * @dev Get the total fees accumulated for a given user and token.
     * @param user The address of the user (User A or B).
     * @param token The address of the token.
     * @return The total fees accumulated for the user and token.
     */
    function getTokensEarnedAmount(address user, address token) external view returns (uint256) {
        return userData[user].tokenToFeeAccumulated[token];
    }

    function userHasToken(address user, address token) public view returns (bool) {
        for (uint256 i = 0; i < userData[user].tokensEarned.length; i++) {
            if (userData[user].tokensEarned[i] == token) {
                return true;
            }
        }
        return false;
    }

    /**
     * @dev Set the address of the DEX aggregator.
     * @param _dexAggregatorV2 The address of the DEX aggregator.
     */
    function setDexAggregatorV2(address _dexAggregatorV2) external onlyOwner {
        dexAggregatorV2 = _dexAggregatorV2;
    }

    function addReferral(address referrer, address referee) internal {
        userData[referee].referrer = referrer;
        userData[referrer].referees.push(referee);
        emit UserReferralAdded(referrer, referee);
    }

    /// Experimental

    /**
     * @dev Checks if a token is allowed in the referral program.
     * @param _tokenAddress The address of the token to check.
     * @return (isAllowed, tokenSymbol) A tuple indicating whether the token is allowed and its symbol if it is allowed.
     */
    function isTokenAllowed(address _tokenAddress) public view returns (bool isAllowed, string memory tokenSymbol) {
        for (uint256 i = 0; i < allowedTokenAddresses.length; i++) {
            if (allowedTokenAddresses[i] == _tokenAddress) {
                return (true, allowedTokenSymbols[i]);
            }
        }
        return (false, "");
    }

    /**
     * @dev Calculates the total USD value of tokens earned by a user.
     * @param user The address of the user (User A or B).
     * @param token The address of the token.
     * @return The total USD value of tokens earned by the user.
     */
    function checkEarnedTokenUSD(address user, address token) internal view returns (uint256) {
        ERC20 _token = ERC20(token);
        (bool isAllowed, string memory tokenSymbol) = isTokenAllowed(token);
        if (!isAllowed) {
            return 0;
        }
        bytes32 dataFeedId = bytes32(tokenSymbol);
        uint256 tokenEarned = userData[user].tokenToFeeAccumulated[token];
        uint256 tokenPriceUSD = getOracleNumericValueFromTxMsg(dataFeedId);
        return (tokenEarned * tokenPriceUSD) / _token.decimals();
    }

}
